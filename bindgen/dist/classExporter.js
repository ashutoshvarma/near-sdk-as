"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassExporter = void 0;
const as_1 = require("visitor-as/as");
const visitor_as_1 = require("visitor-as");
const JSONBuilder_1 = require("./JSONBuilder");
const utils_1 = require("./utils");
const toString = visitor_as_1.utils.toString;
class ClassExporter extends visitor_as_1.ClassDecorator {
    constructor() {
        super(...arguments);
        this.sb = [];
    }
    static get className() {
        return toString(ClassExporter.classSeen.name);
    }
    checkMethods(name) {
        let _class = ClassExporter.classSeen;
        _class.members.forEach(member => {
            if (member instanceof as_1.MethodDeclaration && !member.is(as_1.CommonFlags.PRIVATE)) {
                if (toString(member.name) === name) {
                    throw new Error(`Method "${toString(member.name)}" already used cannot export constructor using the same name.`);
                }
            }
        });
    }
    visitFieldDeclaration(node) {
    }
    visitMethodDeclaration(node) {
        if (node.is(as_1.CommonFlags.SET) || node.is(as_1.CommonFlags.GET)) {
            throw new Error("Exported Singleton class cannot have properties. Found " +
                node.name.text);
        }
        // Private methods should be skipped.
        if (node.is(as_1.CommonFlags.PRIVATE)) {
            return;
        }
        let name = toString(node.name);
        let decorators = (node.decorators || []).map(toString);
        let returnType = toString(node.signature.returnType);
        let origParams = node.signature.parameters.map(visitor_as_1.utils.cloneNode);
        let parameters = origParams.map((param) => {
            if (param.implicitFieldDeclaration) {
                param.name.text = param.name.text.substring(2);
            }
            return toString(param);
        });
        let pramNames = origParams.map((param) => {
            return toString(param.name);
        });
        let isInit = name === "constructor";
        let assertStr = isInit
            ? `assert(isNull(__contract), "contract is already initialized");`
            : `assert(!isNull(__contract), "contract is not initialized");`;
        let isVoid = returnType === "void";
        let body = isInit
            ? `__contract = new ${ClassExporter.className}(${pramNames.join(", ")});`
            : `${!isVoid ? "let res =  " : ""}__contract.${name}(${pramNames.join(", ")});`;
        if (isInit) {
            name = "init";
            parameters = origParams.map((node) => `${toString(node.name)}: ${toString(node.type)}${node.initializer ? " = " + toString(node.initializer) : ""}`);
            returnType = "void";
        }
        if (isInit) {
            if (!decorators.some((decorator) => decorator.includes("exportAs"))) {
                decorators.push(`@exportAs("new")`);
                this.checkMethods("new");
            }
            else {
                let decorator = node.decorators.find(d => toString(d.name) === "exportAs");
                if (decorator.args.length == 1) {
                    this.checkMethods(toString(decorator.args[0]));
                }
            }
        }
        const isChangeMethod = decorators.some((decorator) => decorator.includes("change"));
        this.sb.push(`${decorators.join("\n")}
      export function ${name}(${parameters.join(", ")}): ${returnType} {
  ${assertStr}
  ${body}
  ${isInit || isChangeMethod ? `__setState(__contract);` : ""}
  ${isVoid || isInit ? "" : "return res;"}
}`);
    }
    visitClassDeclaration(node) {
        if (JSONBuilder_1.isEntry(node) && node.is(as_1.CommonFlags.EXPORT)) {
            let name = toString(node.name);
            if (ClassExporter.classSeen) {
                throw new Error(`Cannot export class ${name}. ${ClassExporter.className} already exported. `);
            }
            ClassExporter.classSeen = node;
            this.sb.push(`let __contract: ${name};
if (__checkState()) {
  __contract = __getState<${name}>();
}`);
            this.visit(node.members);
            node.flags = node.flags ^ as_1.CommonFlags.EXPORT;
            let newStatements = utils_1.SimpleParser.parseTopLevel(this.sb.join("\n")).map((n) => {
                if (n instanceof as_1.FunctionDeclaration) {
                    n.flags = n.flags | as_1.CommonFlags.EXPORT;
                    n.flags = n.flags | as_1.CommonFlags.MODULE_EXPORT;
                }
                n.range = node.range;
                return n;
            });
            node.range.source.statements.push(...newStatements);
        }
    }
    get name() {
        return "nearBindgen";
    }
    static visit(source) {
        if (source.sourceKind != as_1.SourceKind.USER_ENTRY) {
            return;
        }
        let visitor = new ClassExporter();
        visitor.visit(source);
    }
}
exports.ClassExporter = ClassExporter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xhc3NFeHBvcnRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9jbGFzc0V4cG9ydGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHNDQVF1QjtBQUN2QiwyQ0FBbUQ7QUFDbkQsK0NBQXdDO0FBQ3hDLG1DQUF1QztBQUV2QyxNQUFNLFFBQVEsR0FBRyxrQkFBSyxDQUFDLFFBQVEsQ0FBQztBQUVoQyxNQUFhLGFBQWMsU0FBUSwyQkFBYztJQUFqRDs7UUFDRSxPQUFFLEdBQWEsRUFBRSxDQUFDO0lBb0lwQixDQUFDO0lBaklDLE1BQU0sS0FBSyxTQUFTO1FBQ2xCLE9BQU8sUUFBUSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVELFlBQVksQ0FBQyxJQUFZO1FBQ3ZCLElBQUksTUFBTSxHQUFHLGFBQWEsQ0FBQyxTQUFTLENBQUM7UUFDckMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDOUIsSUFBSSxNQUFNLFlBQVksc0JBQWlCLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLGdCQUFXLENBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQzFFLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLEVBQUU7b0JBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQ2IsV0FBVyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQywrREFBK0QsQ0FBQyxDQUFBO2lCQUNuRzthQUNGO1FBQ0gsQ0FBQyxDQUFDLENBQUE7SUFFSixDQUFDO0lBRUQscUJBQXFCLENBQUMsSUFBc0I7SUFDNUMsQ0FBQztJQUVELHNCQUFzQixDQUFDLElBQXVCO1FBQzVDLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxnQkFBVyxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsZ0JBQVcsQ0FBQyxHQUFHLENBQUMs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QUM7UUFDbEMsT0FBTyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN4QixDQUFDO0NBQ0Y7QUFySUQsc0NBcUlDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2xhc3NEZWNsYXJhdGlvbixcbiAgRmllbGREZWNsYXJhdGlvbixcbiAgTWV0aG9kRGVjbGFyYXRpb24sXG4gIFNvdXJjZSxcbiAgQ29tbW9uRmxhZ3MsXG4gIFNvdXJjZUtpbmQsXG4gIEZ1bmN0aW9uRGVjbGFyYXRpb24sXG59IGZyb20gXCJ2aXNpdG9yLWFzL2FzXCI7XG5pbXBvcnQgeyB1dGlscywgQ2xhc3NEZWNvcmF0b3IgfSBmcm9tIFwidmlzaXRvci1hc1wiO1xuaW1wb3J0IHsgaXNFbnRyeSB9IGZyb20gXCIuL0pTT05CdWlsZGVyXCI7XG5pbXBvcnQgeyBTaW1wbGVQYXJzZXIgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5jb25zdCB0b1N0cmluZyA9IHV0aWxzLnRvU3RyaW5nO1xuXG5leHBvcnQgY2xhc3MgQ2xhc3NFeHBvcnRlciBleHRlbmRzIENsYXNzRGVjb3JhdG9yIHtcbiAgc2I6IHN0cmluZ1tdID0gW107XG4gIHN0YXRpYyBjbGFzc1NlZW46IENsYXNzRGVjbGFyYXRpb247XG5cbiAgc3RhdGljIGdldCBjbGFzc05hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdG9TdHJpbmcoQ2xhc3NFeHBvcnRlci5jbGFzc1NlZW4ubmFtZSk7XG4gIH1cblxuICBjaGVja01ldGhvZHMobmFtZTogc3RyaW5nKSB7XG4gICAgbGV0IF9jbGFzcyA9IENsYXNzRXhwb3J0ZXIuY2xhc3NTZWVuO1xuICAgIF9jbGFzcy5tZW1iZXJzLmZvckVhY2gobWVtYmVyID0+IHtcbiAgICAgIGlmIChtZW1iZXIgaW5zdGFuY2VvZiBNZXRob2REZWNsYXJhdGlvbiAmJiAhbWVtYmVyLmlzKENvbW1vbkZsYWdzLlBSSVZBVEUpKSB7XG4gICAgICAgIGlmICh0b1N0cmluZyhtZW1iZXIubmFtZSkgPT09IG5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgTWV0aG9kIFwiJHt0b1N0cmluZyhtZW1iZXIubmFtZSl9XCIgYWxyZWFkeSB1c2VkIGNhbm5vdCBleHBvcnQgY29uc3RydWN0b3IgdXNpbmcgdGhlIHNhbWUgbmFtZS5gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgfVxuXG4gIHZpc2l0RmllbGREZWNsYXJhdGlvbihub2RlOiBGaWVsZERlY2xhcmF0aW9uKTogdm9pZCB7XG4gIH1cblxuICB2aXNpdE1ldGhvZERlY2xhcmF0aW9uKG5vZGU6IE1ldGhvZERlY2xhcmF0aW9uKTogdm9pZCB7XG4gICAgaWYgKG5vZGUuaXMoQ29tbW9uRmxhZ3MuU0VUKSB8fCBub2RlLmlzKENvbW1vbkZsYWdzLkdFVCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJFeHBvcnRlZCBTaW5nbGV0b24gY2xhc3MgY2Fubm90IGhhdmUgcHJvcGVydGllcy4gRm91bmQgXCIgK1xuICAgICAgICAgIG5vZGUubmFtZS50ZXh0XG4gICAgICApO1xuICAgIH1cbiAgICAvLyBQcml2YXRlIG1ldGhvZHMgc2hvdWxkIGJlIHNraXBwZWQuXG4gICAgaWYgKG5vZGUuaXMoQ29tbW9uRmxhZ3MuUFJJVkFURSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IG5hbWUgPSB0b1N0cmluZyhub2RlLm5hbWUpO1xuICAgIGxldCBkZWNvcmF0b3JzID0gKG5vZGUuZGVjb3JhdG9ycyB8fCBbXSkubWFwKHRvU3RyaW5nKTtcbiAgICBsZXQgcmV0dXJuVHlwZSA9IHRvU3RyaW5nKG5vZGUuc2lnbmF0dXJlLnJldHVyblR5cGUpO1xuICAgIGxldCBvcmlnUGFyYW1zID0gbm9kZS5zaWduYXR1cmUucGFyYW1ldGVycy5tYXAodXRpbHMuY2xvbmVOb2RlKTtcbiAgICBsZXQgcGFyYW1ldGVycyA9IG9yaWdQYXJhbXMubWFwKChwYXJhbSkgPT4ge1xuICAgICAgaWYgKHBhcmFtLmltcGxpY2l0RmllbGREZWNsYXJhdGlvbikge1xuICAgICAgICBwYXJhbS5uYW1lLnRleHQgPSBwYXJhbS5uYW1lLnRleHQuc3Vic3RyaW5nKDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRvU3RyaW5nKHBhcmFtKTtcbiAgICB9KTtcbiAgICBsZXQgcHJhbU5hbWVzID0gb3JpZ1BhcmFtcy5tYXAoKHBhcmFtKSA9PiB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcocGFyYW0ubmFtZSk7XG4gICAgfSk7XG4gICAgbGV0IGlzSW5pdCA9IG5hbWUgPT09IFwiY29uc3RydWN0b3JcIjtcbiAgICBsZXQgYXNzZXJ0U3RyID0gaXNJbml0XG4gICAgICA/IGBhc3NlcnQoaXNOdWxsKF9fY29udHJhY3QpLCBcImNvbnRyYWN0IGlzIGFscmVhZHkgaW5pdGlhbGl6ZWRcIik7YFxuICAgICAgOiBgYXNzZXJ0KCFpc051bGwoX19jb250cmFjdCksIFwiY29udHJhY3QgaXMgbm90IGluaXRpYWxpemVkXCIpO2A7XG4gICAgbGV0IGlzVm9pZCA9IHJldHVyblR5cGUgPT09IFwidm9pZFwiO1xuICAgIGxldCBib2R5ID0gaXNJbml0XG4gICAgICA/IGBfX2NvbnRyYWN0ID0gbmV3ICR7Q2xhc3NFeHBvcnRlci5jbGFzc05hbWV9KCR7cHJhbU5hbWVzLmpvaW4oXCIsIFwiKX0pO2BcbiAgICAgIDogYCR7IWlzVm9pZCA/IFwibGV0IHJlcyA9ICBcIiA6IFwiXCJ9X19jb250cmFjdC4ke25hbWV9KCR7cHJhbU5hbWVzLmpvaW4oXG4gICAgICAgICAgXCIsIFwiXG4gICAgICAgICl9KTtgO1xuICAgIGlmIChpc0luaXQpIHtcbiAgICAgIG5hbWUgPSBcImluaXRcIjtcbiAgICAgIHBhcmFtZXRlcnMgPSBvcmlnUGFyYW1zLm1hcChcbiAgICAgICAgKG5vZGUpID0+XG4gICAgICAgICAgYCR7dG9TdHJpbmcobm9kZS5uYW1lKX06ICR7dG9TdHJpbmcobm9kZS50eXBlKX0ke1xuICAgICAgICAgICAgbm9kZS5pbml0aWFsaXplciA/IFwiID0gXCIgKyB0b1N0cmluZyhub2RlLmluaXRpYWxpemVyKSA6IFwiXCJcbiAgICAgICAgICB9YFxuICAgICAgKTtcbiAgICAgIHJldHVyblR5cGUgPSBcInZvaWRcIjtcbiAgICB9XG4gICAgaWYgKGlzSW5pdCkge1xuICAgICAgaWYgKCFkZWNvcmF0b3JzLnNvbWUoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLmluY2x1ZGVzKFwiZXhwb3J0QXNcIikpKSB7XG4gICAgICAgIGRlY29yYXRvcnMucHVzaChgQGV4cG9ydEFzKFwibmV3XCIpYCk7XG4gICAgICAgIHRoaXMuY2hlY2tNZXRob2RzKFwibmV3XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGRlY29yYXRvciA9IG5vZGUuZGVjb3JhdG9ycyEuZmluZChkID0+IHRvU3RyaW5nKGQubmFtZSkgPT09IFwiZXhwb3J0QXNcIikhO1xuICAgICAgICBpZiAoZGVjb3JhdG9yLmFyZ3MhLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgdGhpcy5jaGVja01ldGhvZHModG9TdHJpbmcoZGVjb3JhdG9yLmFyZ3MhWzBdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaXNDaGFuZ2VNZXRob2QgPSBkZWNvcmF0b3JzLnNvbWUoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLmluY2x1ZGVzKFwiY2hhbmdlXCIpKTtcbiAgICB0aGlzLnNiLnB1c2goXG4gICAgICBgJHtkZWNvcmF0b3JzLmpvaW4oXCJcXG5cIil9XG4gICAgICBleHBvcnQgZnVuY3Rpb24gJHtuYW1lfSgke3BhcmFtZXRlcnMuam9pbihcIiwgXCIpfSk6ICR7cmV0dXJuVHlwZX0ge1xuICAke2Fzc2VydFN0cn1cbiAgJHtib2R5fVxuICAke2lzSW5pdCB8fCBpc0NoYW5nZU1ldGhvZCA/IGBfX3NldFN0YXRlKF9fY29udHJhY3QpO2AgOiBcIlwifVxuICAke2lzVm9pZCB8fCBpc0luaXQgPyBcIlwiIDogXCJyZXR1cm4gcmVzO1wifVxufWBcbiAgICApO1xuICB9XG5cbiAgdmlzaXRDbGFzc0RlY2xhcmF0aW9uKG5vZGU6IENsYXNzRGVjbGFyYXRpb24pOiB2b2lkIHtcbiAgICBpZiAoaXNFbnRyeShub2RlKSAmJiBub2RlLmlzKENvbW1vbkZsYWdzLkVYUE9SVCkpIHtcbiAgICAgIGxldCBuYW1lID0gdG9TdHJpbmcobm9kZS5uYW1lKTtcbiAgICAgIGlmIChDbGFzc0V4cG9ydGVyLmNsYXNzU2Vlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENhbm5vdCBleHBvcnQgY2xhc3MgJHtuYW1lfS4gJHtDbGFzc0V4cG9ydGVyLmNsYXNzTmFtZX0gYWxyZWFkeSBleHBvcnRlZC4gYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgQ2xhc3NFeHBvcnRlci5jbGFzc1NlZW4gPSBub2RlO1xuICAgICAgdGhpcy5zYi5wdXNoKFxuICAgICAgICBgbGV0IF9fY29udHJhY3Q6ICR7bmFtZX07XG5pZiAoX19jaGVja1N0YXRlKCkpIHtcbiAgX19jb250cmFjdCA9IF9fZ2V0U3RhdGU8JHtuYW1lfT4oKTtcbn1gXG4gICAgICApO1xuICAgICAgdGhpcy52aXNpdChub2RlLm1lbWJlcnMpO1xuICAgICAgbm9kZS5mbGFncyA9IG5vZGUuZmxhZ3MgXiBDb21tb25GbGFncy5FWFBPUlQ7XG4gICAgICBsZXQgbmV3U3RhdGVtZW50cyA9IFNpbXBsZVBhcnNlci5wYXJzZVRvcExldmVsKHRoaXMuc2Iuam9pbihcIlxcblwiKSkubWFwKFxuICAgICAgICAobikgPT4ge1xuICAgICAgICAgIGlmIChuIGluc3RhbmNlb2YgRnVuY3Rpb25EZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgbi5mbGFncyA9IG4uZmxhZ3MgfCBDb21tb25GbGFncy5FWFBPUlQ7XG4gICAgICAgICAgICBuLmZsYWdzID0gbi5mbGFncyB8IENvbW1vbkZsYWdzLk1PRFVMRV9FWFBPUlQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIG4ucmFuZ2UgPSBub2RlLnJhbmdlO1xuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgbm9kZS5yYW5nZS5zb3VyY2Uuc3RhdGVtZW50cy5wdXNoKC4uLm5ld1N0YXRlbWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBuYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFwibmVhckJpbmRnZW5cIjtcbiAgfVxuXG4gIHN0YXRpYyB2aXNpdChzb3VyY2U6IFNvdXJjZSk6IHZvaWQge1xuICAgIGlmIChzb3VyY2Uuc291cmNlS2luZCAhPSBTb3VyY2VLaW5kLlVTRVJfRU5UUlkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHZpc2l0b3IgPSBuZXcgQ2xhc3NFeHBvcnRlcigpO1xuICAgIHZpc2l0b3IudmlzaXQoc291cmNlKTtcbiAgfVxufVxuIl19