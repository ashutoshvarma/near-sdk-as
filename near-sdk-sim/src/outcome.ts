/// <reference path="./types.ts" />

import { RustRef } from "./utils";
import * as sim from "../sim-ffi";

/**
 * An ExecutionResult is created by a UserAccount submitting a transaction.
 * It wraps an ExecutionOutcome which is the same object returned from an RPC call.
 */
export class ExecutionResult extends RustRef {
  /**
   * Interpret the SuccessValue as a JSON value
   */
  unwrap_json_value(): string {
    return sim.$er$unwrap_json_value(this.ref);
  }

  /**
   * Check if transaction was successful
   */
  is_ok(): boolean {
    return sim.$er$is_ok(this.ref);
  }

  /**
   * Test whether there is a SuccessValue
   */
  has_value(): boolean {
    return sim.$er$has_value(this.ref);
  }

  /**
   * Lookup an execution result from a hash
   */
  lookup_hash(hash: string): ExecutionResult | null {
    const res = sim.$er$lookup_hash(this.ref, hash);
    if (res.length == 0) {
      return null;
    } else {
      return new ExecutionResult(res[0]);
    }
  }

  /**
   * Returns the internal ExecutionOutcome
   */
  outcome(): ExecutionOutcome {
    return JSON.parse(sim.$er$outcome(this.ref));
  }

  /**
   * Return results of promises from the `receipt_ids` in the ExecutionOutcome
   */
  get_receipt_results(): Array<ExecutionResult> {
    return sim
      .$er$get_receipt_results(this.ref)
      .map((r) => new ExecutionResult(r));
  }

  /**
   * Return the results of any promises created since the last transaction
   */
  promise_results(): Array<ExecutionResult> {
    return sim.$er$promise_results(this.ref).map((r) => new ExecutionResult(r));
  }

  promise_errors(): Array<ExecutionResult> {
    return sim.$er$promise_errors(this.ref).map((r) => new ExecutionResult(r));
  }

  /**
   * Execution status. Contains the result in case of successful execution.
   */
  status(): ExecutionStatus {
    return JSON.parse(sim.$er$status(this.ref));
  }

  /**
   * The amount of the gas burnt by the given transaction or receipt.
   */
  gas_burnt(): Gas {
    return sim.$er$gas_burnt(this.ref);
  }

  /**
   * The amount of tokens burnt corresponding to the burnt gas amount.
   * This value doesn't always equal to the `gas_burnt` multiplied by the gas price, because
   * the prepaid gas price might be lower than the actual gas price and it creates a deficit.
   */
  tokens_burnt(): Balance {
    return sim.$er$gas_burnt(this.ref);
  }

  /**
   * Logs from this transaction or receipt.
   */
  logs(): string[] {
    return sim.$er$logs(this.ref);
  }

  /**
   * The id of the account on which the execution happens. For transaction this is signer_id,
   * for receipt this is receiver_id.
   */
  executor_id(): AccountId {
    return sim.$er$executor_id(this.ref);
  }

  /**
   * Receipt IDs generated by this transaction or receipt.
   */
  receipt_ids(): CryptoHash[] {
    return sim.$er$receipt_ids(this.ref);
  }
}
